<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/itags.core/itags.core.js - Itsa</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Itsa"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Array.html">Array</a></li>
            
                <li><a href="../classes/document.html">document</a></li>
            
                <li><a href="../classes/Element.html">Element</a></li>
            
                <li><a href="../classes/ElementArray.html">ElementArray</a></li>
            
                <li><a href="../classes/Event.html">Event</a></li>
            
                <li><a href="../classes/Event.Emitter.html">Event.Emitter</a></li>
            
                <li><a href="../classes/Event.Listener.html">Event.Listener</a></li>
            
                <li><a href="../classes/FocusManager.html">FocusManager</a></li>
            
                <li><a href="../classes/Function.html">Function</a></li>
            
                <li><a href="../classes/IO.html">IO</a></li>
            
                <li><a href="../classes/Node.html">Node</a></li>
            
                <li><a href="../classes/NS-vdom.html">NS-vdom</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/Plugins.html">Plugins</a></li>
            
                <li><a href="../classes/Promise.html">Promise</a></li>
            
                <li><a href="../classes/String.html">String</a></li>
            
                <li><a href="../classes/Utils.html">Utils</a></li>
            
                <li><a href="../classes/vnode.html">vnode</a></li>
            
                <li><a href="../classes/window.html">window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/attribute-extractor.html">attribute-extractor</a></li>
            
                <li><a href="../modules/element-array.html">element-array</a></li>
            
                <li><a href="../modules/element-plugin.html">element-plugin</a></li>
            
                <li><a href="../modules/event.html">event</a></li>
            
                <li><a href="../modules/event-dom.html">event-dom</a></li>
            
                <li><a href="../modules/event-emitter.html">event-emitter</a></li>
            
                <li><a href="../modules/event-listener.html">event-listener</a></li>
            
                <li><a href="../modules/extend-document.html">extend-document</a></li>
            
                <li><a href="../modules/extend-element.html">extend-element</a></li>
            
                <li><a href="../modules/focusmanager.html">focusmanager</a></li>
            
                <li><a href="../modules/html-parser.html">html-parser</a></li>
            
                <li><a href="../modules/io.html">io</a></li>
            
                <li><a href="../modules/itsa.build.html">itsa.build</a></li>
            
                <li><a href="../modules/js-ext.html">js-ext</a></li>
            
                <li><a href="../modules/lib_array.js.html">lib/array.js</a></li>
            
                <li><a href="../modules/lib_function.js.html">lib/function.js</a></li>
            
                <li><a href="../modules/lib_object.js.html">lib/object.js</a></li>
            
                <li><a href="../modules/lib_promise.s.html">lib/promise.s</a></li>
            
                <li><a href="../modules/lib_string.js.html">lib/string.js</a></li>
            
                <li><a href="../modules/node-parser.html">node-parser</a></li>
            
                <li><a href="../modules/node-win.html">node-win</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
                <li><a href="../modules/vdom.html">vdom</a></li>
            
                <li><a href="../modules/vdom-ns.html">vdom-ns</a></li>
            
                <li><a href="../modules/vnode.html">vnode</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/itags.core/itags.core.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">

/*jshint proto:true */

&quot;use strict&quot;;

require(&#x27;polyfill/polyfill-base.js&#x27;);
require(&#x27;./css/itags.core.css&#x27;);

var jsExt = require(&#x27;js-ext/js-ext.js&#x27;), // want the full version: include it at the top, so that object.merge is available
    createHashMap = require(&#x27;js-ext/extra/hashmap.js&#x27;).createMap,
    asyncSilent = require(&#x27;utils&#x27;).asyncSilent,
    laterSilent = require(&#x27;utils&#x27;).laterSilent,
    CLASS_ITAG_RENDERED = &#x27;itag-rendered&#x27;,
    DEFAULT_CHAIN_INIT = true,
    DEFAULT_CHAIN_DESTROY = true,
    Classes = jsExt.Classes,
    NODE = &#x27;node&#x27;,
    REMOVE = &#x27;remove&#x27;,
    INSERT = &#x27;insert&#x27;,
    CHANGE = &#x27;change&#x27;,
    ATTRIBUTE = &#x27;attribute&#x27;,
    NODE_REMOVED = NODE+REMOVE,
    NODE_INSERTED = NODE+INSERT,
    NODE_CONTENT_CHANGE = NODE+&#x27;content&#x27;+CHANGE,
    ATTRIBUTE_REMOVED = ATTRIBUTE+REMOVE,
    ATTRIBUTE_CHANGED = ATTRIBUTE+CHANGE,
    ATTRIBUTE_INSERTED = ATTRIBUTE+INSERT,
    DELAYED_EVT_TIME = 1000,
    NATIVE_OBJECT_OBSERVE = !!Object.observe,
    ITAG_METHODS = createHashMap({
        init: &#x27;_initUI&#x27;,
        sync: &#x27;_syncUI&#x27;,
        destroy: &#x27;_destroyUI&#x27;,
        args: &#x27;_args&#x27;
    }),
    // ITAG_METHOD_VALUES must match previous ITAG_METHODS&#x27;s values!
    ITAG_METHOD_VALUES = createHashMap({
        _initUI: true,
        _syncUI: true,
        _destroyUI: true,
        _args: true
    }),
    NOOP = function() {};

module.exports = function (window) {
NATIVE_OBJECT_OBSERVE=false;

    var DOCUMENT = window.document,
        PROTOTYPE_CHAIN_CAN_BE_SET = arguments[1], // hidden feature, used by unit-test
        RUNNING_ON_NODE = (typeof global !== &#x27;undefined&#x27;) &amp;&amp; (global.window!==window),
        PROTO_SUPPORTED = !!Object.__proto__,
        itagCore, MUTATION_EVENTS, PROTECTED_MEMBERS, EXTRA_BASE_MEMBERS, Event, IO,
        ATTRIBUTE_EVENTS, registerDelay, focusManager, mergeFlat;

    require(&#x27;vdom&#x27;)(window);
    Event = require(&#x27;event-dom&#x27;)(window);
    IO = require(&#x27;io&#x27;)(window);

/*jshint boss:true */
    if (itagCore=window._ItagCore) {
/*jshint boss:false */
        return itagCore; // itagCore was already defined
    }

    Object.protectedProp(window, &#x27;ITAGS&#x27;, {}); // for the ProtoConstructors

    EXTRA_BASE_MEMBERS = {
        initUI: function(constructor, reInitialize) {
            var instance = this,
                vnode = instance.vnode,
                superInit;
            if ((reInitialize || !vnode.ce_initialized) &amp;&amp; !vnode.removedFromDOM &amp;&amp; !vnode.ce_destroyed) {
                superInit = function(constructor) {
                    var classCarierBKP = instance.__classCarier__;
                    if (constructor.$$chainInited) {
                        instance.__classCarier__ = constructor.$$super.constructor;
                        superInit(constructor.$$super.constructor);
                    }
                    classCarierBKP = instance.__classCarier__;
                    // don&#x27;t call &#x60;hasOwnProperty&#x60; directly on obj --&gt; it might have been overruled
                    Object.prototype.hasOwnProperty.call(constructor.prototype, &#x27;_initUI&#x27;) &amp;&amp; constructor.prototype._initUI.call(instance);
                };
                if (reInitialize) {
                    instance.setHTML(vnode.ce_initContent);
                }
                else {
                    // already synced on the server:
                    // bind the stored json-data on the property &#x60;model&#x60;:
                    itagCore.retrieveModel(instance);
                    Object.protectedProp(vnode, &#x27;ce_initContent&#x27;, instance.getHTML());
                }
                superInit(constructor || instance.constructor);
                Object.protectedProp(vnode, &#x27;ce_initialized&#x27;, true);
            }
            return instance;
        },
        destroyUI: function(constructor, reInitialize) {
            var instance = this,
                vnode = instance.vnode,
                superDestroy, observer;
            if (vnode.ce_initialized &amp;&amp; (reInitialize || vnode.removedFromDOM) &amp;&amp; !vnode.ce_destroyed) {
                if (!reInitialize &amp;&amp; NATIVE_OBJECT_OBSERVE) {
                    observer = instance.getData(&#x27;_observer&#x27;);
                    observer &amp;&amp; Object.unobserve(instance.model, observer);
                }
                superDestroy = function(constructor) {
                    var classCarierBKP = instance.__classCarier__;
                    // don&#x27;t call &#x60;hasOwnProperty&#x60; directly on obj --&gt; it might have been overruled
                    Object.prototype.hasOwnProperty.call(constructor.prototype, &#x27;_destroyUI&#x27;) &amp;&amp; constructor.prototype._destroyUI.call(instance);
                    if (constructor.$$chainDestroyed) {
                        instance.__classCarier__ = constructor.$$super.constructor;
                        superDestroy(constructor.$$super.constructor);
                    }
                    classCarierBKP = instance.__classCarier__;
                };
                superDestroy(constructor || instance.constructor);
                instance.detachAll();
                reInitialize || Object.protectedProp(vnode, &#x27;ce_destroyed&#x27;, true);
            }
            return instance;
        },
        syncUI: function() {
            var instance = this,
                args = instance.args,
                vnode = instance.vnode;
            if (vnode.ce_initialized &amp;&amp; !vnode.removedFromDOM &amp;&amp; !vnode.ce_destroyed) {
                vnode._setUnchangableAttrs(args);
                instance._syncUI.apply(instance, arguments);
                vnode._setUnchangableAttrs(null);
            }
            return instance;
        },
        reInitializeUI: function(constructor) {
            var instance = this,
                vnode = instance.vnode;
            if (vnode.ce_initialized &amp;&amp; !vnode.removedFromDOM &amp;&amp; !vnode.ce_destroyed) {
                instance.destroyUI(constructor, true)
                        .initUI(constructor, true)
                        .syncUI();
            }
            return instance;
        },
        bindModel: function(model) {
            var instance = this,
                stringifiedData, prevContent, observer;
            if (NATIVE_OBJECT_OBSERVE) {
                observer = instance.getData(&#x27;_observer&#x27;);
                observer &amp;&amp; Object.unobserve(instance.model, observer);
            }
            instance.model = model;
            if (NATIVE_OBJECT_OBSERVE) {
                observer = function() {
                    instance.syncUI();
                };
                Object.observe(instance.model, observer);
                instance.setData(&#x27;_observer&#x27;, observer);
            }
            instance.syncUI();
            if (RUNNING_ON_NODE) {
                // store the modeldata inside an inner div-node
                try {
                    stringifiedData = JSON.stringify(model);
                    prevContent = instance.getElement(&#x27;span.itag-data&#x27;);
                    prevContent &amp;&amp; prevContent.remove();
                    instance.prepend(&#x27;&lt;span class=&quot;itag-data&quot;&gt;&#x27;+stringifiedData+&#x27;&lt;/span&gt;&#x27;);
                }
                catch(e) {
                    console.warn(e);
                }
            }
        },
        isRendered: function() {
            return !!this.getData(&#x27;itagRendered&#x27;);
        },
        _initUI: NOOP,
        _destroyUI: NOOP,
        _syncUI: NOOP,
        _args: {},
        _modelToAttrs: function() {
            var instance = this,
                args = instance._args,
                model = instance.model,
                newAttrs = [];
            args.each(function(value, key) {
                newAttrs[newAttrs.length] = {name: key, value: model[key]};
            });
            (newAttrs.length&gt;0) &amp;&amp; instance.setAttrs(newAttrs, true);
            return instance;
        },
        _attrsToModel: function() {
            var instance = this,
                args = instance._args,
                model = instance.model,
                attrValue;
            args.each(function(value, key) {
                attrValue = instance.getAttr(key);
                switch (value) {
                    case &#x27;boolean&#x27;:
                        attrValue = (attrValue===&#x27;true&#x27;);
                        break;
                    case &#x27;number&#x27;:
                        attrValue = parseFloat(attrValue);
                        break;
                    case &#x27;date&#x27;:
                        attrValue = attrValue.toDate();
                        break;
                }
                model[key] = attrValue;
            });
            return instance;
        },
    };

    EXTRA_BASE_MEMBERS.merge(Event.Listener)
                      .merge(Event._CE_listener);

    PROTECTED_MEMBERS = createHashMap();
    EXTRA_BASE_MEMBERS.each(function(value, key) {
        ITAG_METHOD_VALUES[key] || (PROTECTED_MEMBERS[key] = true);
    });

    MUTATION_EVENTS = [NODE_REMOVED, NODE_INSERTED, NODE_CONTENT_CHANGE, ATTRIBUTE_REMOVED, ATTRIBUTE_CHANGED, ATTRIBUTE_INSERTED];
    ATTRIBUTE_EVENTS = [ATTRIBUTE_REMOVED, ATTRIBUTE_CHANGED, ATTRIBUTE_INSERTED];

    mergeFlat = function(constructor, domElement) {
        var prototype = constructor.prototype,
            keys, i, name, propDescriptor;
        if (domElement.__addedProps__) {
            // set before: erase previous properties
            domElement.__addedProps__.each(function(value, key) {
                delete domElement[key];
            });
        }
        domElement.__addedProps__ = {};
        while (prototype !== window.HTMLElement.prototype) {
            keys = Object.getOwnPropertyNames(prototype);
/*jshint boss:true */
            for (i=0; name=keys[i]; i++) {
/*jshint boss:false */
                if (!domElement.__addedProps__[name]) {
                    propDescriptor = Object.getOwnPropertyDescriptor(prototype, name);
                    propDescriptor.configurable = true;
                    // needs configurable, otherwise we cannot delete it when refreshing
                    Object.defineProperty(domElement, name, propDescriptor);
                    domElement.__addedProps__[name] = true;
                }
            }
            constructor = constructor.$$super.constructor;
            prototype = constructor.prototype;
        }
    };

    focusManager = function(element) {
        var focusManagerNode = element.getElement(&#x27;[focusmanager].focussed&#x27;);
        focusManagerNode &amp;&amp; focusManagerNode.focus();
    };

    itagCore = {

        DELAYED_FINALIZE_EVENTS: {
            &#x27;mousedown&#x27;: true,
            &#x27;mouseup&#x27;: true,
            &#x27;mousemove&#x27;: true,
            &#x27;panmove&#x27;: true,
            &#x27;panstart&#x27;: true,
            &#x27;panleft&#x27;: true,
            &#x27;panright&#x27;: true,
            &#x27;panup&#x27;: true,
            &#x27;pandown&#x27;: true,
            &#x27;pinchmove&#x27;: true,
            &#x27;rotatemove&#x27;: true,
            // &#x27;focus&#x27;: true, // focus needs immediate response !
            &#x27;manualfocus&#x27;: true,
            // &#x27;keydown&#x27;: true, // keydown needs immediate response !
            &#x27;keyup&#x27;: true
            //&#x27;keypress&#x27;: true, // keypress needs immediate response !
            //&#x27;blur&#x27;: true, // blur needs immediate response !
        },

        itagFilter: function(e) {
            return e.target.vnode.isItag;
        },

        renderDomElements: function(itagName, domElementConstructor) {
            var itagElements = DOCUMENT.getAll(itagName),
                len = itagElements.length,
                i, itagElement;
            for (i=0; i&lt;len; i++) {
                itagElement = itagElements[i];
                this.upgradeElement(itagElement, domElementConstructor);
            }
        },

        upgradeElement: function(domElement, domElementConstructor) {
            var instance = this,
                proto = domElementConstructor.prototype,
                observer;
            domElement.model = {};
            if (NATIVE_OBJECT_OBSERVE) {
                observer = function() {
                    instance.syncUI();
                };
                Object.observe(domElement.model, observer);
                domElement.setData(&#x27;_observer&#x27;, observer);
            }
            if (!PROTO_SUPPORTED) {
                mergeFlat(domElementConstructor, domElement);
                domElement.__proto__ = proto;
                domElement.__classCarier__ = domElementConstructor;
                domElement.after(&#x27;itag:prototypechanged&#x27;, function(e) {
                    var prototypes = e.prototypes;
                    mergeFlat(domElementConstructor, domElement);
                    if (&#x27;init&#x27; in prototypes) {
                        domElement.reInitializeUI(domElement.__proto__.constructor);
                    }
                    else if (&#x27;sync&#x27; in prototypes) {
                        domElement.syncUI();
                    }
                });
                domElement.after(&#x27;itag:prototyperemoved&#x27;, function(e) {
                    var properties = e.properties;
                    mergeFlat(domElementConstructor, domElement);
                    if (properties.contains(&#x27;init&#x27;)) {
                        domElement.reInitializeUI(domElement.__proto__.constructor);
                    }
                    else if (properties.contains(&#x27;sync&#x27;)) {
                        domElement.syncUI();
                    }
                });
            }
            else {
                domElement.__proto__ = proto;
                domElement.__classCarier__ = domElementConstructor;
            }
            // sync, but do this after the element is created:
            // in the next eventcycle:
            asyncSilent(function(){
                domElement._attrsToModel();
                domElement.initUI(PROTO_SUPPORTED ? null : domElementConstructor);
                domElement.syncUI();
                instance.setRendered(domElement);
            });
        },

        retrieveModel: function(domElement) {
            // try to load the model from a stored inner div-node
            var dataNode = domElement.getElement(&#x27;span.itag-data&#x27;),
                stringifiedData;
            if (dataNode) {
                try {
                    stringifiedData = dataNode.getHTML();
                    domElement.model = JSON.parseWithDate(stringifiedData);
                    dataNode.remove(true);
                }
                catch(e) {
                    console.warn(e);
                }
            }
            return domElement.model;
        },

        setRendered: function(domElement) {
            domElement.setClass(CLASS_ITAG_RENDERED, null, null, true);
            domElement.setData(&#x27;itagRendered&#x27;, true);
            domElement._itagReady || (domElement._itagReady=window.Promise.manage());
            domElement._itagReady.fulfill();
        },

        setupWatchers: function() {
            Event.after(
                NODE_REMOVED,
                function(e) {
                    var node = e.target;
                    node.destroyUI(PROTO_SUPPORTED ? null : node.__proto__.constructor);
                },
                itagCore.itagFilter
            );

            // Always watch for attibute change-events:
            // this way, we make the itags responsive for manual domchanges.
            Event.after(
                ATTRIBUTE_EVENTS,
                function(e) {
                    var element = e.target;
                    element._attrsToModel();
                    NATIVE_OBJECT_OBSERVE || DOCUMENT.refreshItags();
                    // this affect modeldata, the event.finalizer will sync the UI
                    // AFTER synced, we might need to refocus --&gt; that&#x27;s why refocussing
                    // is done async.
                    if (element.hasClass(&#x27;focussed&#x27;)) {
                        asyncSilent(function() {
                            focusManager(element);
                        });
                    }
                },
                itagCore.itagFilter
            );

            if (!NATIVE_OBJECT_OBSERVE) {
                Event.finalize(function(e) {
                    var type = e.type;
                    if (!MUTATION_EVENTS[type] &amp;&amp; !type.endsWith(&#x27;outside&#x27;)) {
                        if (itagCore.DELAYED_FINALIZE_EVENTS[type]) {
                            registerDelay || (registerDelay = laterSilent(function() {
                                DOCUMENT.refreshItags();
                                registerDelay = null;
                            }, DELAYED_EVT_TIME));
                        }
                        else {
                            DOCUMENT.refreshItags();
                        }
                    }
                });

                IO.finalize(function() {
                    DOCUMENT.refreshItags();
                });

                // we patch the window timer functions in order to run &#x60;refreshItags&#x60; afterwards:
                window._setTimeout = window.setTimeout;
                window._setInterval = window.setInterval;

                window.setTimeout = function() {
                    var args = arguments;
                    args[0] = (function(originalFn) {
                        return function() {
                            originalFn();
                            DOCUMENT.refreshItags();
                        };
                    })(args[0]);
                    window._setTimeout.apply(this, arguments);
                };

                window.setInterval = function() {
                    var args = arguments;
                    args[0] = (function(originalFn) {
                        return function() {
                            originalFn();
                            DOCUMENT.refreshItags();
                        };
                    })(args[0]);
                    window._setInterval.apply(this, arguments);
                };

                if (typeof window.setImmediate !== &#x27;undefined&#x27;) {
                    window._setImmediate = window.setImmediate;
                    window.setImmediate = function() {
                        var args = arguments;
                        args[0] = (function(originalFn) {
                            return function() {
                                originalFn();
                                DOCUMENT.refreshItags();
                            };
                        })(args[0]);
                        window._setImmediate.apply(this, arguments);
                    };
                }
            }
        }
    };

    DOCUMENT._createElement = DOCUMENT.createElement;
    DOCUMENT.createElement = function(tag) {
        var ItagClass = window.ITAGS[tag.toLowerCase()];
        if (ItagClass) {
            return new ItagClass();
        }
        return this._createElement(tag);
    };


    (function(FunctionPrototype) {
        var originalSubClass = FunctionPrototype.subClass;

        FunctionPrototype._mergePrototypes = FunctionPrototype.mergePrototypes;
        FunctionPrototype.mergePrototypes = function(prototypes, force) {
            var instance = this,
                silent;
            if (!instance.$$itag) {
                // default mergePrototypes
                instance._mergePrototypes.apply(instance, arguments);
            }
            else {
                instance._mergePrototypes(prototypes, force, ITAG_METHODS, PROTECTED_MEMBERS);
                silent = arguments[2];
                silent || Event.emit(instance, &#x27;itag:prototypechanged&#x27;, {prototypes: prototypes, force: force});
            }
            return instance;
        };

        FunctionPrototype._removePrototypes = FunctionPrototype.removePrototypes;
        FunctionPrototype.removePrototypes = function(properties) {
            var instance = this;
            if (!instance.$$itag) {
                // default mergePrototypes
                instance._removePrototypes.apply(instance, arguments);
            }
            else {
                instance._removePrototypes(properties, ITAG_METHODS);
                Event.emit(instance, &#x27;itag:prototyperemoved&#x27;, {properties: properties});
            }
            return instance;
        };

        FunctionPrototype.subClass = function(constructor, prototypes, chainInit, chainDestroy) {
            var instance = this,
                baseProt, proto, domElementConstructor, itagName;
            if (typeof constructor === &#x27;string&#x27;) {
                // Itag subclassing
                if (typeof prototypes === &#x27;boolean&#x27;) {
                    chainDestroy = chainInit;
                    chainInit = prototypes;
                    prototypes = null;
                }
                (typeof chainInit === &#x27;boolean&#x27;) || (chainInit=DEFAULT_CHAIN_INIT);
                (typeof chainDestroy === &#x27;boolean&#x27;) || (chainDestroy=DEFAULT_CHAIN_DESTROY);

                itagName = constructor.toLowerCase();
                if (window.ITAGS[itagName]) {
                    console.warn(itagName+&#x27; already exists: it will be redefined&#x27;);
                }

                // if instance.isItag, then we subclass an existing i-tag
                baseProt = instance.prototype;
                proto = Object.create(baseProt);

                // merge some system function in case they don&#x27;t exists
                domElementConstructor = function() {
                    var domElement = DOCUMENT._createElement(itagName);
                    itagCore.upgradeElement(domElement, domElementConstructor);
                    return domElement;
                };

                domElementConstructor.prototype = proto;

                proto.constructor = domElementConstructor;
                domElementConstructor.$$itag = itagName;
                domElementConstructor.$$chainInited = chainInit ? true : false;
                domElementConstructor.$$chainDestroyed = chainDestroy ? true : false;
                domElementConstructor.$$super = baseProt;
                domElementConstructor.$$orig = {};

                prototypes &amp;&amp; domElementConstructor.mergePrototypes(prototypes, true, true);
                window.ITAGS[itagName] = domElementConstructor;

                itagCore.renderDomElements(itagName, domElementConstructor);

                return domElementConstructor;
            }
            else {
                // Function subclassing
                return originalSubClass.apply(instance, arguments);
            }
        };

    }(Function.prototype));



    var createItagBaseClass = function () {
        return Function.prototype.subClass.apply(window.HTMLElement);
    };

    /**
     * Returns a base class with the given constructor and prototype methods
     *
     * @for Object
     * @method createClass
     * @param [constructor] {Function} constructor for the class
     * @param [prototype] {Object} Hash map of prototype members of the new class
     * @static
     * @return {Function} the new class
    */
    Object.protectedProp(Classes, &#x27;ItagBaseClass&#x27;, createItagBaseClass().mergePrototypes(EXTRA_BASE_MEMBERS, true, {}, {}));

    // because &#x60;mergePrototypes&#x60; cannot merge object-getters, we will add the getter &#x60;$super&#x60; manually:
    Object.defineProperties(Classes.ItagBaseClass.prototype, Classes.coreMethods);

    Object.defineProperty(Classes.ItagBaseClass.prototype, &#x27;$superProp&#x27;, {
        value: function(/* func, *args */) {
            var instance = this,
                classCarierReturn = instance.__$superCarierStart__ || instance.__classCarier__ || instance.__methodClassCarier__,
                currentClassCarier = instance.__classCarier__ || instance.__methodClassCarier__,
                args = arguments,
                superClass, superPrototype, firstArg, returnValue;

            instance.__$superCarierStart__ = null;
            if (args.length === 0) {
                instance.__classCarier__ = classCarierReturn;
                return;
            }

            superClass = currentClassCarier.$$super.constructor,
            superPrototype = superClass.prototype,
            firstArg = Array.prototype.shift.apply(args); // will decrease the length of args with one
            firstArg = ITAG_METHODS[firstArg] || firstArg;
            (firstArg === &#x27;_initUI&#x27;) &amp;&amp; (firstArg=&#x27;initUI&#x27;); // to re-initiate chaining
            (firstArg === &#x27;_destroyUI&#x27;) &amp;&amp; (firstArg=&#x27;destroyUI&#x27;); // to re-initiate chaining
            if ((firstArg===&#x27;initUI&#x27;) &amp;&amp; currentClassCarier.$$chainInited) {
                console.warn(&#x27;init cannot be invoked manually, because the Class is &#x60;chainInited&#x60;&#x27;);
                return currentClassCarier;
            }

            if ((firstArg===&#x27;destroyUI&#x27;) &amp;&amp; currentClassCarier.$$chainDestroyed) {
                console.warn(&#x27;destroy cannot be invoked manually, because the Class is &#x60;chainDestroyed&#x60;&#x27;);
                return currentClassCarier;
            }

            if (typeof superPrototype[firstArg] === &#x27;function&#x27;) {
                instance.__classCarier__ = superClass;
                if ((firstArg===&#x27;initUI&#x27;) || (firstArg===&#x27;destroyUI&#x27;)) {
                    returnValue = superPrototype[firstArg].call(instance, instance.__classCarier__);
                }
                else {
                    returnValue = superPrototype[firstArg].apply(instance, args);
                }
            }
            instance.__classCarier__ = classCarierReturn;
            return returnValue || superPrototype[firstArg];
        }
    });

    /**
     * Returns a base class with the given constructor and prototype methods
     *
     * @for Object
     * @method createClass
     * @param [constructor] {Function} constructor for the class
     * @param [prototype] {Object} Hash map of prototype members of the new class
     * @static
     * @return {Function} the new class
    */
    Object.protectedProp(DOCUMENT, &#x27;createItag&#x27;, Classes.ItagBaseClass.subClass.bind(Classes.ItagBaseClass));




    (function(HTMLElementPrototype) {
        HTMLElementPrototype.isItag = function() {
            return !!this.vnode.tag.startsWith(&#x27;I-&#x27;);
        };
        HTMLElementPrototype.itagReady = function() {
            var instance = this;
            if (!instance.isItag()) {
                console.warn(&#x27;itagReady() invoked on a non-itag element&#x27;);
                return window.Promise.reject(&#x27;Element is no itag&#x27;);
            }
            instance._itagReady || (instance._itagReady=window.Promise.manage());
            return instance._itagReady;
        };
    }(window.HTMLElement.prototype));

    (function(ElementPrototype) {
        var setAttributeBKP = ElementPrototype.setAttribute;
        var removeAttributeBKP = ElementPrototype.removeAttribute;

        ElementPrototype.removeAttribute = function(attributeName) {
            var instance = this;
            if (!instance.isItag()) {
                removeAttributeBKP.apply(instance, arguments);
            }
            else {
                if (instance._args[attributeName]) {
                    delete instance.model[attributeName];
                }
                else {
                    removeAttributeBKP.apply(instance, arguments);
                }
            }
        };
        ElementPrototype.setAttribute = function(attributeName, value, silent) {
            var instance = this,
                valueType;
            if (silent || !instance.isItag()) {
                setAttributeBKP.apply(instance, arguments);
            }
            else {
/*jshint boss:true */
                if (valueType=instance._args[attributeName]) {
/*jshint boss:false */
                    switch (valueType) {
                        case &#x27;boolean&#x27;:
                            value = (value===&#x27;true&#x27;);
                            break;
                        case &#x27;number&#x27;:
                            value = parseFloat(value);
                            break;
                        case &#x27;date&#x27;:
                            value = value.toDate();
                            break;
                    }
                    instance.model[attributeName] = value;
                }
                else {
                    setAttributeBKP.apply(instance, arguments);
                }
            }
        };
    }(window.Element.prototype));

    DOCUMENT.refreshItags = function() {
        var list = this.getItags(),
            len = list.length,
            i, itagElement;
        for (i=0; i&lt;len; i++) {
            itagElement = list[i];
            if (itagElement.isRendered &amp;&amp; itagElement.isRendered()) {

// console.info(&#x27;refreshItags before: &#x27;+JSON.stringify(itagElement.model));

                itagElement._modelToAttrs();
                itagElement.syncUI();

// console.info(&#x27;refreshItags after: &#x27;+JSON.stringify(itagElement.model));
                itagElement.hasClass(&#x27;focussed&#x27;) &amp;&amp; focusManager(itagElement);
            }
        }
    };


    if (PROTO_SUPPORTED) {
        Event.after(
            &#x27;itag:prototypechanged&#x27;,
            function(e) {
                var prototypes = e.prototypes,
                    ItagClass = e.target,
                    nodeList, node, i, length;
                if (&#x27;init&#x27; in prototypes) {
                    nodeList = DOCUMENT.getAll(ItagClass.$$itag+&#x27;.&#x27;+CLASS_ITAG_RENDERED);
                    length = nodeList.length;
                    for (i=0; i&lt;length; i++) {
                        node = nodeList[i];
                        node.reInitializeUI();
                    }
                }
                else if (&#x27;sync&#x27; in prototypes) {
                    nodeList = DOCUMENT.getAll(ItagClass.$$itag+&#x27;.&#x27;+CLASS_ITAG_RENDERED);
                    length = nodeList.length;
                    for (i=0; i&lt;length; i++) {
                        node = nodeList[i];
                        node.syncUI();
                    }
                }
            }
        );
        Event.after(
            &#x27;itag:prototyperemoved&#x27;,
            function(e) {
                var properties = e.properties,
                    ItagClass = e.target,
                    nodeList, node, i, length;
                if (properties.contains(&#x27;init&#x27;)) {
                    nodeList = DOCUMENT.getAll(ItagClass.$$itag+&#x27;.&#x27;+CLASS_ITAG_RENDERED);
                    length = nodeList.length;
                    for (i=0; i&lt;length; i++) {
                        node = nodeList[i];
                        node.reInitializeUI();
                    }
                }
                else if (properties.contains(&#x27;sync&#x27;)) {
                    nodeList = DOCUMENT.getAll(ItagClass.$$itag+&#x27;.&#x27;+CLASS_ITAG_RENDERED);
                    length = nodeList.length;
                    for (i=0; i&lt;length; i++) {
                        node = nodeList[i];
                        node.syncUI();
                    }
                }
            }
        );
    }

    itagCore.setupWatchers();

    Object.protectedProp(window, &#x27;_ItagCore&#x27;, itagCore);

    if (PROTOTYPE_CHAIN_CAN_BE_SET) {
        itagCore.setPrototypeChain = function(activate) {
            PROTO_SUPPORTED = activate ? !!Object.__proto__ : false;
        };
    }

    return itagCore;

};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
